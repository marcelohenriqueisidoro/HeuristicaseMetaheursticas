# -*- coding: utf-8 -*-
"""VNS e ILS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LuiqelT1ZUnLwMJ-sISfzMslL4bwrrUd

VNS

> Problema da Mochila
"""

import numpy as np
import math
import random

def busca_local(s, b, p, n, pena):
  fo = calcula_fo(b, p, s, n, cap, pena)
  flag = 1
  while flag:
    flag = 0
    melhor, bi = melhor_vizinho(s, b, p, n, pena)
    if melhor > fo:
      s[bi] = 1 - s[bi]
      fo = melhor
      flag = 1
      #print(s)
      #print(fo)
  return s, fo
def melhor_vizinho(s, b, p, n, pena):
  melhor = -math.inf
  for i in range(n):
    s[i] = 1 - s[i] #Troca o bit
    f = calcula_fo(b, p, s, n, cap, pena)
    s[i] = 1 - s[i] #destroca
    if f > melhor:
      melhor = f
      bi = i
  return melhor, bi
def gera_sol(sol, taxa):
  for i in range(len(sol)):
    x = np.random.random()
    if x < taxa:
      sol[i] = 1
  return sol

def calcula_fo(b, p, s, n, cap, pena):
  fo = 0
  pt = 0
  for i in range(n):
    fo = fo + s[i]*b[i]
    pt = pt + s[i]*p[i]
  if pt > cap:
    #print('Solução inviável')
    fo = fo -pena*(pt - cap)
  return fo

def vizinho_rand(sol, k):
  for i in range(k):
    j = random.randint(0, len(sol)-1)
    sol[j] = 1 - sol[j]
  return sol
#DADOS DO PROBLEMA-------------------#
n = 8 #Quantidade de objetos
beneficio = [4, 3, 2, 6, 2, 3, 5, 4]
peso =      [5, 4, 3, 9, 4, 2, 6, 7]
cap = 20 #Capacidade da mochila
#------------------------------------#
#PARÂMETROS--------------------------#
penalidade = 10 #Penalidade por solução inviável
taxa = 0.50    #Taxa para gerar sol. inicial, deve ser entre (0,1)
np.random.seed(100)
#------------------------------------#
v = 3
k = 1
iter = 20
f_star = -math.inf
sol_star = n*[0]
sol = n*[0] #Vetor para guardar a Solução
sol = gera_sol(sol, taxa)
print(sol)
fo = calcula_fo(beneficio, peso, sol, n, cap, penalidade)
print(fo)

while k <= v:
  sol = vizinho_rand(sol, k)
  sol, fo = busca_local(sol, beneficio, peso, n, penalidade)
  if fo > f_star:
    f_star = fo
    for j in range(n):
      sol_star[j] = sol[j]
    print('Melhorou na vizinhança', k)
    k = 1
  else:
    k = k+1
    for j in range(n):
      sol[j] = sol_star[j]

print(sol_star)
print(f_star)

"""> Problema de Alocação de Tarefas"""

import math
import random
import numpy as np
inf = math.inf

def calcula_fo(sol, tempos, n):
  fo = 0
  for i in range(1, n):
    col = sol[i-1]
    lin = sol[i]
    #print('Tarefa', lin,'depois da ', col)
    fo = fo + tempos[lin][col]
  return fo

def gera_sol(sol, n):
  v = []
  for g in range(1, 7):
    v.append(g)
  #print(v)
  v = np.random.permutation(v)
  #print(v)
  for i in range(1, 7):
    sol[i] = v[i-1]
  return sol

def melhor_vizinho(sol, tempos, n):
  melhor = math.inf
  bi = 0
  bj = 0
  for i in range(1, n-1):
    for j in range(i+1, n):
      #troca
      aux = sol[i]
      sol[i] = sol[j]
      sol[j] = aux
      f = calcula_fo(sol, tempos, n)
      #destroca
      aux = sol[i]
      sol[i] = sol[j]
      sol[j] = aux
      if f < melhor:
        melhor = f
        bi = i
        bj = j
  return melhor, bi, bj

def busca_local(sol, tempos, n):
  fo_star = calcula_fo(sol, tempos, n)
  fo, i, j = melhor_vizinho(sol, tempos, n)
  #print('Função Objetivo', fo)
  aux = sol[i]
  sol[i] = sol[j]
  sol[j] = aux
  if fo < fo_star:
   melhor_iter = iter
   fo_star = fo
   for i in range(n):
     sol_star[i] = sol[i]
  return sol_star, fo_star

def vizinho_rand(sol, k):
  for i in range(k):
    j = random.randint(1, 6)
    t = random.randint(1, 6)
    aux = sol[j]
    sol[j] = sol[t]
    sol[t] = aux
  return sol

n = 7
tempos =  [
           [inf, inf, inf, inf, inf, inf, inf],
           [5, inf, 3, 9, 4, 2, 6],
           [3, 3, inf, 6, 2, 3, 5],
           [4, 9, 6, inf, 7, 2, 6],
           [7, 4, 2, 7, inf, 4, 8],
           [2, 2, 3, 3, 4, inf, 1],
           [1, 6, 5, 5, 8, 1, inf]
           ]

#------------------------------------#
v = 3
k = 1
iter = 20
f_star = math.inf
sol_star = n*[0]
sol = n*[0] #Vetor para guardar a Solução
sol = gera_sol(sol, taxa)
print(sol)
fo = calcula_fo(sol, tempos, n)
print(fo)

while k <= v:
  sol = gera_sol(sol, n)
  sol, fo = busca_local(sol, tempos, n)
  if fo < f_star:
    f_star = fo
    for j in range(n):
      sol_star[j] = sol[j]
    print('Melhorou na vizinhança', k)
    k = 1
  else:
    k = k+1
    for j in range(n):
      sol[j] = sol_star[j]

print(sol_star)
print(f_star)

"""ILS

> Para o problema da Mochila
"""

import numpy as np
import math
import random

def busca_local(s, b, p, n, pena):
  fo = calcula_fo(b, p, s, n, cap, pena)
  flag = 1
  while flag:
    flag = 0
    melhor, bi = melhor_vizinho(s, b, p, n, pena)
    if melhor > fo:
      s[bi] = 1 - s[bi]
      fo = melhor
      flag = 1
      #print(s)
      #print(fo)
  return s, fo
def melhor_vizinho(s, b, p, n, pena):
  melhor = -math.inf
  for i in range(n):
    s[i] = 1 - s[i] #Troca o bit
    f = calcula_fo(b, p, s, n, cap, pena)
    s[i] = 1 - s[i] #destroca
    if f > melhor:
      melhor = f
      bi = i
  return melhor, bi
def gera_sol(sol, taxa):
  for i in range(len(sol)):
    x = np.random.random()
    if x < taxa:
      sol[i] = 1
  return sol

def calcula_fo(b, p, s, n, cap, pena):
  fo = 0
  pt = 0
  for i in range(n):
    fo = fo + s[i]*b[i]
    pt = pt + s[i]*p[i]
  if pt > cap:
    #print('Solução inviável')
    fo = fo -pena*(pt - cap)
  return fo

def vizinho_rand(sol, k):
  for i in range(k):
    j = random.randint(0, len(sol)-1)
    sol[j] = 1 - sol[j]
  return sol
#DADOS DO PROBLEMA-------------------#
n = 8 #Quantidade de objetos
beneficio = [4, 3, 2, 6, 2, 3, 5, 4]
peso =      [5, 4, 3, 9, 4, 2, 6, 7]
cap = 20 #Capacidade da mochila
#------------------------------------#
#PARÂMETROS--------------------------#
penalidade = 10 #Penalidade por solução inviável
taxa = 0.50    #Taxa para gerar sol. inicial, deve ser entre (0,1)
#np.random.seed(100)
#------------------------------------#
IterSemMelhora = 50
k = 1
iter = 0
f_star = -math.inf
sol_star = n*[0]
sol = n*[0] #Vetor para guardar a Solução
sol = gera_sol(sol, taxa)
print(sol)
fo = calcula_fo(beneficio, peso, sol, n, cap, penalidade)
print(fo)

while iter <= IterSemMelhora:
  iter = iter + 1
  sol, fo = busca_local(sol, beneficio, peso, n, penalidade)
  if fo > f_star:
    f_star = fo
    for j in range(n):
      sol_star[j] = sol[j]
    iter = 0
  if iter < IterSemMelhora/2:
    sol = vizinho_rand(sol_star, 1)
  else:
    sol = vizinho_rand(sol, 3)


print(sol_star)
print(f_star)

"""> Para o Problema de Alocação de Tarefas"""

import math
import random
import numpy as np
inf = math.inf

def calcula_fo(sol, tempos, n):
  fo = 0
  for i in range(1, n):
    col = sol[i-1]
    lin = sol[i]
    #print('Tarefa', lin,'depois da ', col)
    fo = fo + tempos[lin][col]
  return fo

def gera_sol(sol, n):
  v = []
  for g in range(1, 7):
    v.append(g)
  #print(v)
  v = np.random.permutation(v)
  #print(v)
  for i in range(1, 7):
    sol[i] = v[i-1]
  return sol

def melhor_vizinho(sol, tempos, n):
  melhor = math.inf
  bi = 0
  bj = 0
  for i in range(1, n-1):
    for j in range(i+1, n):
      #troca
      aux = sol[i]
      sol[i] = sol[j]
      sol[j] = aux
      f = calcula_fo(sol, tempos, n)
      #destroca
      aux = sol[i]
      sol[i] = sol[j]
      sol[j] = aux
      if f < melhor:
        melhor = f
        bi = i
        bj = j
  return melhor, bi, bj

def busca_local(sol, tempos, n):
  fo_star = calcula_fo(sol, tempos, n)
  fo, i, j = melhor_vizinho(sol, tempos, n)
  #print('Função Objetivo', fo)
  aux = sol[i]
  sol[i] = sol[j]
  sol[j] = aux
  if fo < fo_star:
   melhor_iter = iter
   fo_star = fo
   for i in range(n):
     sol_star[i] = sol[i]
  return sol_star, fo_star

def vizinho_rand(sol, k):
  for i in range(k):
    j = random.randint(1, 6)
    t = random.randint(1, 6)
    aux = sol[j]
    sol[j] = sol[t]
    sol[t] = aux
  return sol

n = 7
tempos =  [
           [inf, inf, inf, inf, inf, inf, inf],
           [5, inf, 3, 9, 4, 2, 6],
           [3, 3, inf, 6, 2, 3, 5],
           [4, 9, 6, inf, 7, 2, 6],
           [7, 4, 2, 7, inf, 4, 8],
           [2, 2, 3, 3, 4, inf, 1],
           [1, 6, 5, 5, 8, 1, inf]
           ]

#------------------------------------#
IterSemMelhora = 10
k = 1
iter = 0
f_star = math.inf
sol_star = n*[0]
sol = n*[0] #Vetor para guardar a Solução
sol = gera_sol(sol, n)
print(sol)
fo = calcula_fo(sol, tempos, n)
print(fo)

while iter <= IterSemMelhora:
  iter = iter + 1
  sol, fo = busca_local(sol, tempos, n)
  if fo < f_star:
    f_star = fo
    for j in range(n):
      sol_star[j] = sol[j]
    iter = 0
  if iter < IterSemMelhora/2:
    sol = vizinho_rand(sol_star, 1)
  else:
    sol = vizinho_rand(sol, 3)


print(sol_star)
print(f_star)